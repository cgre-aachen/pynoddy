<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pynoddy.output &mdash; pynoddy  documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="pynoddy  documentation" href="../../index.html" />
    <link rel="up" title="pynoddy" href="../pynoddy.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pynoddy  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../pynoddy.html" accesskey="U">pynoddy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pynoddy.output</h1><div class="highlight"><pre>
<span class="sd">&#39;&#39;&#39;Noddy output file analysis</span>
<span class="sd">Created on 24/03/2014</span>

<span class="sd">@author: Florian Wellmann, Sam Thiele</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">pynoddy</span>

<div class="viewcode-block" id="NoddyOutput"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput">[docs]</a><span class="k">class</span> <span class="nc">NoddyOutput</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class definition for Noddy output analysis&quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Noddy output analysis</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">            - *output_name* = string : (base) name of Noddy output files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">=</span> <span class="n">output_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_model_info</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_geology</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define addition as addition of grid block values</span>
<span class="sd">        </span>
<span class="sd">        Note: Check first if model dimensions and settings are the same</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># check dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compare_dimensions_to</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="c"># 1. create copy</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="n">tmp_his</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c"># 2. perform operation</span>
        <span class="n">tmp_his</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">block</span>
        <span class="k">return</span> <span class="n">tmp_his</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define subtraction as subtraction of grid block values</span>
<span class="sd">        </span>
<span class="sd">        Note: Check first if model dimensions and settings are the same</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># check dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compare_dimensions_to</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="c"># 1. create copy</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="n">tmp_his</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c"># 2. perform operation</span>
        <span class="n">tmp_his</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">block</span>
        <span class="k">return</span> <span class="n">tmp_his</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Augmented assignment addtition: add value to all grid blocks</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">            - *x*: can be either a numerical value (int, float, ...) *or* another</span>
<span class="sd">            NoddyOutput object! Note that, in both cases, the own block is updated</span>
<span class="sd">            and no new object is created (compare to overwritten addition operator!)</span>
<span class="sd">        </span>
<span class="sd">        Note: This method is changing the object *in place*!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># if x is another pynoddy output object, then add values to own grid in place!</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NoddyOutput</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">+=</span> <span class="n">x</span><span class="o">.</span><span class="n">block</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">+=</span> <span class="n">x</span>
        <span class="c"># update grid values</span>
        
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Augmented assignment addtition: add value(s) to all grid blocks</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">            - *x*: can be either a numerical value (int, float, ...) *or* another</span>
<span class="sd">            NoddyOutput object! Note that, in both cases, the own block is updated</span>
<span class="sd">            and no new object is created (compare to overwritten addition operator!)</span>
<span class="sd">        </span>
<span class="sd">        Note: This method is changing the object *in place*!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># if x is another pynoddy output object, then add values to own grid in place!</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NoddyOutput</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">-=</span> <span class="n">x</span><span class="o">.</span><span class="n">block</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">-=</span> <span class="n">x</span>
        <span class="c"># update grid values</span>
        
        <span class="k">return</span> <span class="bp">self</span>
    
<div class="viewcode-block" id="NoddyOutput.set_basename"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput.set_basename">[docs]</a>    <span class="k">def</span> <span class="nf">set_basename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set model basename&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">=</span> <span class="n">name</span>
        
        </div>
<div class="viewcode-block" id="NoddyOutput.compare_dimensions_to"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput.compare_dimensions_to">[docs]</a>    <span class="k">def</span> <span class="nf">compare_dimensions_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare model dimensions to another model&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;Model dimensions do not seem to agree, please check!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">delx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dely</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delz</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">delx</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dely</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">delz</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;Model dimensions do not seem to agree, please check!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">zmin</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;Model dimensions do not seem to agree, please check!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="NoddyOutput.load_model_info"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput.load_model_info">[docs]</a>    <span class="k">def</span> <span class="nf">load_model_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load information about model discretisation from .g00 file&quot;&quot;&quot;</span>
        <span class="n">filelines</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;.g00&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span> 
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">filelines</span><span class="p">:</span>
            <span class="k">if</span> <span class="s">&#39;NUMBER OF LAYERS&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s">&#39;LAYER 1 DIMENSIONS&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]]</span>
            <span class="k">elif</span> <span class="s">&#39;UPPER SW CORNER&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]]</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">)</span> <span class="o">=</span> <span class="n">l</span>
            <span class="k">elif</span> <span class="s">&#39;LOWER NE CORNER&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]]</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">=</span> <span class="n">l</span>
            <span class="k">elif</span> <span class="s">&#39;NUM ROCK&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_rocktypes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent_z</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> 
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dely</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delz</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent_x</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> 
                                             <span class="bp">self</span><span class="o">.</span><span class="n">extent_y</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">),</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">extent_z</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>
        <span class="c">#load lithology colours &amp; relative ages</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;.g20&quot;</span><span class="p">):</span>
            <span class="n">filelines</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;.g20&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_events</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">filelines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span> <span class="c">#number of events</span>
            <span class="n">lithos</span> <span class="o">=</span> <span class="n">filelines</span><span class="p">[</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_events</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">filelines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="c">#litho definitions</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">rock_ids</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#list of litho ids. Will be a list from 1 to n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rock_names</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#the (string) names of each rock type. Note that names including spaces will not be read properly.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rock_colors</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#the colours of each rock type (in Noddy).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rock_events</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#list of the events that created different lithologies</span>
            
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lithos</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rock_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rock_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rock_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rock_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span><span class="o">/</span><span class="mf">255.</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mf">255.</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">255.</span><span class="p">)</span> <span class="p">)</span>
            
            <span class="c">#calculate stratigraphy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stratigraphy</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#litho id&#39;s ordered by the age they were created in</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rock_events</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c">#loop through events</span>
                <span class="c">#create list of lithos created in this event</span>
                <span class="n">lithos</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rock_events</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span> <span class="c">#current event</span>
                        <span class="n">lithos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rock_ids</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                
                <span class="c">#reverse order... Noddy litho id&#39;s are ordered by event, but reverse ordered within depositional events (ie.</span>
                <span class="c">#lithologies created in younger events have larger ids, however the youngest unit created in a given event</span>
                <span class="c">#will have the smallest id...</span>
                
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">lithos</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stratigraphy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                
            </div>
<div class="viewcode-block" id="NoddyOutput.load_geology"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput.load_geology">[docs]</a>    <span class="k">def</span> <span class="nf">load_geology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load block geology ids from .g12 output file&quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;.g12&quot;</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;standard&#39;</span> <span class="c"># standard method to read file</span>
        <span class="c"># method = &#39;numpy&#39;    # using numpy should be faster - but it messes up the order... possible to fix?</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;standard&#39;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">:</span>
                    <span class="c"># next z-slice</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c"># reset x counter</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">continue</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span> <span class="k">for</span> <span class="n">l1</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
              
        
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;standard_old&#39;</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> 
            <span class="n">j_max</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">k_max</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i_max</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">:</span>
                    <span class="c"># next y-slice</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">j_max</span> <span class="p">:</span> <span class="n">j_max</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">l1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">i_max</span><span class="p">:</span> <span class="n">i_max</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">&gt;</span> <span class="n">k_max</span> <span class="p">:</span> <span class="n">k_max</span> <span class="o">=</span> <span class="n">k</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
            <span class="k">print</span> <span class="n">i_max</span><span class="p">,</span> <span class="n">j_max</span><span class="p">,</span> <span class="n">k_max</span>
                    
        
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;numpy&#39;</span><span class="p">:</span>
            <span class="c"># old implementation - didn&#39;t work, but why?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;int&quot;</span><span class="p">)</span>
            <span class="c"># reshape to proper 3-D shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="c"># self.block = np.swapaxes(self.block, 0, 1)</span>
            <span class="c"># print np.shape(self.block)</span>
    </div>
<div class="viewcode-block" id="NoddyOutput.determine_unit_volumes"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput.determine_unit_volumes">[docs]</a>    <span class="k">def</span> <span class="nf">determine_unit_volumes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine volumes of geological units in the discretized block model</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#</span>
        <span class="c"># Note: for the time being, the following implementation is extremely simple</span>
        <span class="c"># and could be optimised, for example to test specifically for units defined</span>
        <span class="c"># in stratigraphies, intrusions, etc.!</span>
        <span class="c"># </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dely</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_ids</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">unit_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_ids</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit_volumes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span> <span class="o">==</span> <span class="n">unit_id</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_volume</span>
       </div>
<div class="viewcode-block" id="NoddyOutput.get_surface_grid"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput.get_surface_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_surface_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lithoID</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a grid of lines that define a grid on the specified surface. Note that this cannot</span>
<span class="sd">        handle layers that are repeated in the z direction...</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">         - *lithoID* - the top surface of this lithology will be calculated. If a list is passed,</span>
<span class="sd">                       the top surface of each lithology in the list is calculated.</span>
<span class="sd">         </span>
<span class="sd">        **Keywords**:</span>
<span class="sd">         - *res* - the resolution to sample at. Default is 2 (ie. every second voxel is sampled).</span>
<span class="sd">         </span>
<span class="sd">        **Returns**:</span>
<span class="sd">         a tuple containing lists of tuples of x, y and z coordinate dictionaries and colour dictionaries, </span>
<span class="sd">         one containing the east-west lines and one the north-south lines: ((x,y,z,c),(x,y,z,c)). THe dictionary</span>
<span class="sd">         keys are the lithoID&#39;s passed in the lithoID parameter.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="kn">as</span> <span class="nn">ma</span>
        
        <span class="n">cube_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;res&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">lithoID</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">lithoID</span> <span class="o">=</span> <span class="p">[</span><span class="n">lithoID</span><span class="p">]</span>
            
        <span class="n">sx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c">#get surface locations in x direction</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="n">res</span><span class="p">):</span>
            
             <span class="c">#start new line</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lithoID</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sx</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="c">#create list</span>
                    <span class="n">sx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">sy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">sz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;rock_colors&#39;</span><span class="p">)):</span>
                        <span class="n">sc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rock_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                        
                <span class="n">sx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">sy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">sz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                
            <span class="c">#fill in line</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="n">res</span><span class="p">):</span>
                <span class="c">#drill down filling surface info</span>
                <span class="n">found</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">geo</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="ow">in</span> <span class="n">lithoID</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="p">]</span>                          
                        <span class="c">#add point</span>
                        <span class="n">sx</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="n">sy</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="n">sz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        
                        <span class="c">#remember that we&#39;ve found this</span>
                        <span class="n">found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="c">#check to see if anything has been missed(and hence we should start a new line segment)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lithoID</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">found</span><span class="p">:</span>
                        <span class="n">sx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span> <span class="c">#new list</span>
                        <span class="n">sy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        <span class="n">sz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c">#apply mask</span>
        <span class="c">#for d in [sx,sy,sz]:</span>
        <span class="c">#    for k in d.keys():</span>
        <span class="c">#        d[key] = ma.masked_where(np.array(d[key]) == -1,d[key])</span>
                
        <span class="n">xlines</span> <span class="o">=</span> <span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="n">sy</span><span class="p">,</span><span class="n">sz</span><span class="p">,</span><span class="n">sc</span><span class="p">)</span>
        
        <span class="n">sx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c">#get surface locations in y direction</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="n">res</span><span class="p">):</span>
            
            <span class="c">#start new line</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lithoID</span><span class="p">:</span> 
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sx</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="c">#create list</span>
                    <span class="n">sx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">sy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">sz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;rock_colors&#39;</span><span class="p">)):</span>
                        <span class="n">sc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rock_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">sx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">sy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">sz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                
            <span class="c">#fill in line</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="n">res</span><span class="p">):</span>
                <span class="c">#drill down filling surface info</span>
                <span class="n">found</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">geo</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="ow">in</span> <span class="n">lithoID</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="p">]</span>                           
                        <span class="c">#add point</span>
                        <span class="n">sx</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="n">sy</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="n">sz</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="n">found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                        
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lithoID</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">found</span><span class="p">:</span> <span class="c">#line should end</span>
                        <span class="n">sx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span> <span class="c">#add line end</span>
                        <span class="n">sy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        <span class="n">sz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        
        <span class="n">ylines</span> <span class="o">=</span> <span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="n">sy</span><span class="p">,</span><span class="n">sz</span><span class="p">,</span><span class="n">sc</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">xlines</span><span class="p">,</span><span class="n">ylines</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="NoddyOutput.get_section_lines"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput.get_section_lines">[docs]</a>    <span class="k">def</span> <span class="nf">get_section_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create and returns a list of lines representing a section block through the model</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">            - *direction* = &#39;x&#39;, &#39;y&#39;, &#39;z&#39; : coordinate direction of section plot (default: &#39;y&#39;)</span>
<span class="sd">            - *position* = int or &#39;center&#39; : cell position of section as integer value</span>
<span class="sd">                or identifier (default: &#39;center&#39;)</span>
<span class="sd">        **Returns**:</span>
<span class="sd">        A tuple of lists of dictionaries.... ie:</span>
<span class="sd">        ( [ dictionary of x coordinates, with lithology pairs as keys, separated by an underscore],</span>
<span class="sd">          [ dictionary of y coordinates, with lithology pairs as keys, separated by an underscore],</span>
<span class="sd">          [ dictionary of z coordinates, with lithology pairs as keys, separated by an underscore],</span>
<span class="sd">          [ dictionary of colours, with lithologies as keys])</span>
<span class="sd">          </span>
<span class="sd">        For example: get_section_lines()[0][&quot;1_2&quot;] returns a list of all the x coordinates from the </span>
<span class="sd">        contact between lithology 1 and lithology 2. Note that the smaller lithology index always</span>
<span class="sd">        comes first in the code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c">#calc cube size</span>
        <span class="n">cube_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span>
        
        
        <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">if</span> <span class="s">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">direction</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">):</span>
               <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="c">#this is a contact</span>
                        <span class="n">code</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%d</span><span class="s">_</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
                            <span class="n">x</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">y</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">z</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            
                        <span class="n">x</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="n">y</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="n">z</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;rock_colors&#39;</span><span class="p">)):</span>
                            <span class="n">c</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rock_colors</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">c</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    
        <span class="c">##xz</span>
        <span class="k">if</span> <span class="s">&#39;y&#39;</span> <span class="ow">in</span> <span class="n">direction</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">):</span>
               <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span> <span class="c">#this is a contact</span>
                        <span class="n">code</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%d</span><span class="s">_</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
                            <span class="n">x</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">y</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">z</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            
                        <span class="n">x</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="n">y</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">)</span>
                        <span class="n">z</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;rock_colors&#39;</span><span class="p">)):</span>
                            <span class="n">c</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rock_colors</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">c</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    
        <span class="c">#yz</span>
        <span class="k">if</span> <span class="s">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">direction</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">):</span>
               <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span> <span class="c">#this is a contact</span>
                        <span class="n">code</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%d</span><span class="s">_</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
                            <span class="n">x</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">y</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">z</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            
                        <span class="n">x</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">)</span>
                        <span class="n">y</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="n">z</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">cube_size</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;rock_colors&#39;</span><span class="p">)):</span>
                            <span class="n">c</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rock_colors</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">c</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
            </div>
<div class="viewcode-block" id="NoddyOutput.get_section_voxels"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput.get_section_voxels">[docs]</a>    <span class="k">def</span> <span class="nf">get_section_voxels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create and returns section block through the model</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">            - *direction* = &#39;x&#39;, &#39;y&#39;, &#39;z&#39; : coordinate direction of section plot (default: &#39;y&#39;)</span>
<span class="sd">            - *position* = int or &#39;center&#39; : cell position of section as integer value</span>
<span class="sd">                or identifier (default: &#39;center&#39;)</span>
<span class="sd">              </span>
<span class="sd">        **Optional Keywords**:</span>
<span class="sd">            - *data* = np.array : data to plot, if different to block data itself</span>
<span class="sd">            - *litho_filter* = a list of lithologies to draw. All others will be ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;data&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;x&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s">&#39;center&#39;</span><span class="p">:</span>
                <span class="n">cell_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell_pos</span> <span class="o">=</span> <span class="n">position</span>
                
            <span class="n">section_slice</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">cell_pos</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="c">#xlabel = &quot;y&quot;</span>
            <span class="c">#ylabel = &quot;z&quot;</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;y&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s">&#39;center&#39;</span><span class="p">:</span>
                <span class="n">cell_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell_pos</span> <span class="o">=</span> <span class="n">position</span>
                
            <span class="n">section_slice</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">cell_pos</span><span class="p">,:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="c">#xlabel = &quot;x&quot;</span>
            <span class="c">#ylabel = &quot;z&quot;</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;z&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s">&#39;center&#39;</span><span class="p">:</span>
                <span class="n">cell_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell_pos</span> <span class="o">=</span> <span class="n">position</span>
                
            <span class="n">section_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[:,:,</span><span class="n">cell_pos</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Error: </span><span class="si">%s</span><span class="s"> is not a valid direction. Please specify either (&#39;x&#39;,&#39;y&#39; or &#39;z&#39;).&quot;</span> <span class="o">%</span> <span class="n">direction</span>
        
        <span class="c">#filter by lithology if a filter is set</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;litho_filter&#39;</span><span class="p">):</span>
            <span class="n">litho_filter</span> <span class="o">=</span> <span class="n">kwds</span><span class="p">[</span><span class="s">&#39;litho_filter&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">litho_filter</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">section_slice</span><span class="p">)):</span>
                    <span class="n">mask</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">section_slice</span><span class="p">[</span><span class="n">x</span><span class="p">])):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">(</span><span class="n">section_slice</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">])</span> <span class="ow">in</span> <span class="n">litho_filter</span><span class="p">:</span>
                            <span class="c">#section_slice[x][y] = -1 #null values</span>
                            <span class="n">mask</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">mask</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
                        
                    
                <span class="c">#apply mask</span>
                <span class="n">section_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">section_slice</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
                <span class="c">#section_slice = np.ma.masked_where(mask, section_slice)</span>

        <span class="k">return</span> <span class="n">section_slice</span><span class="p">,</span> <span class="n">cell_pos</span>
        
        
        </div>
<div class="viewcode-block" id="NoddyOutput.plot_section"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput.plot_section">[docs]</a>    <span class="k">def</span> <span class="nf">plot_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a section block through the model</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">            - *direction* = &#39;x&#39;, &#39;y&#39;, &#39;z&#39; : coordinate direction of section plot (default: &#39;y&#39;)</span>
<span class="sd">            - *position* = int or &#39;center&#39; : cell position of section as integer value</span>
<span class="sd">                or identifier (default: &#39;center&#39;)</span>
<span class="sd">        </span>
<span class="sd">        **Optional Keywords**:</span>
<span class="sd">            - *ax* = matplotlib.axis : append plot to axis (default: create new plot)</span>
<span class="sd">            - *figsize* = (x,y) : matplotlib figsize</span>
<span class="sd">            - *colorbar* = bool : plot colorbar (default: True)</span>
<span class="sd">            - *colorbar_orientation* = &#39;horizontal&#39; or &#39;vertical&#39; : orientation of colorbar</span>
<span class="sd">                    (default: &#39;vertical&#39;)</span>
<span class="sd">            - *title* = string : plot title</span>
<span class="sd">            - *savefig* = bool : save figure to file (default: show directly on screen)</span>
<span class="sd">            - *cmap* = matplotlib.cmap : colormap (default: YlOrRd)</span>
<span class="sd">            - *fig_filename* = string : figure filename</span>
<span class="sd">            - *ve* = float : vertical exaggeration</span>
<span class="sd">            - *layer_labels* = list of strings: labels for each unit in plot</span>
<span class="sd">            - *layers_from* = noddy history file : get labels automatically from history file</span>
<span class="sd">            - *data* = np.array : data to plot, if different to block data itself</span>
<span class="sd">            - *litho_filter* = a list of lithologies to draw. All others will be ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#try importing matplotlib</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;Could not draw image as matplotlib is not installed. Please install matplotlib&quot;</span><span class="p">)</span>
            
        <span class="n">cbar_orientation</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;colorbar_orientation&quot;</span><span class="p">,</span> <span class="s">&#39;vertical&#39;</span><span class="p">)</span>
        <span class="n">litho_filter</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;litho_filter&quot;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        
        <span class="c"># determine if data are passed - if not, then recompute model</span>
        <span class="c">#data = kwds.get(&#39;data&#39;,self.block)</span>
        <span class="n">ve</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;ve&quot;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">cmap_type</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;cmap&#39;</span><span class="p">,</span> <span class="s">&#39;YlOrRd&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;ax&#39;</span><span class="p">):</span>
            <span class="c"># append plot to existing axis</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">kwds</span><span class="p">[</span><span class="s">&#39;ax&#39;</span><span class="p">]</span>
            <span class="n">return_axis</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_axis</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">figsize</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;figsize&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">savefig</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;savefig&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">colorbar</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;colorbar&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
            
        <span class="c"># extract slice</span>
        <span class="c">#if kwds.has_key(&#39;data&#39;):     </span>
        <span class="n">section_slice</span><span class="p">,</span> <span class="n">cell_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_section_voxels</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span><span class="n">position</span><span class="p">,</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="c">#else:</span>
        <span class="c">#    section_slice, cell_pos = self.get_section_voxels(direction,position,litho_filter=litho_filter)</span>
            
        <span class="c">#calculate axis labels</span>
        <span class="k">if</span> <span class="s">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">direction</span><span class="p">:</span>
            <span class="n">xlabel</span><span class="o">=</span><span class="s">&quot;y&quot;</span>
            <span class="n">ylabel</span><span class="o">=</span><span class="s">&quot;z&quot;</span>
        <span class="k">elif</span> <span class="s">&#39;y&#39;</span> <span class="ow">in</span> <span class="n">direction</span><span class="p">:</span>
            <span class="n">xlabel</span> <span class="o">=</span> <span class="s">&quot;x&quot;</span>
            <span class="n">ylabel</span> <span class="o">=</span> <span class="s">&quot;z&quot;</span>
        <span class="k">elif</span> <span class="s">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">direction</span><span class="p">:</span>
            <span class="n">xlabel</span> <span class="o">=</span> <span class="s">&quot;x&quot;</span>
            <span class="n">ylabel</span> <span class="o">=</span> <span class="s">&quot;y&quot;</span>
            
        <span class="c">#plot section</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">,</span> <span class="s">&quot;Section in </span><span class="si">%s</span><span class="s">-direction, pos=</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">cell_pos</span><span class="p">))</span>
                
        <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">section_slice</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">ve</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_type</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="s">&#39;lower left&#39;</span><span class="p">)</span>
       
        <span class="k">if</span> <span class="n">colorbar</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kwds</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;ax&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">False</span><span class="p">:</span> <span class="c">#disable - color bar is broken</span>
<span class="c">#            cbar = plt.colorbar(im)</span>
<span class="c">#            _ = cbar</span>
<span class="c">#        </span>
            <span class="kn">import</span> <span class="nn">matplotlib</span> <span class="kn">as</span> <span class="nn">mpl</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">section_slice</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">section_slice</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">BoundaryNorm</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">cmap</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="n">cbar_orientation</span> <span class="o">==</span> <span class="s">&#39;horizontal&#39;</span><span class="p">:</span>
                <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.775</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">])</span>
                <span class="n">cb</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colorbar</span><span class="o">.</span><span class="n">ColorbarBase</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_type</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="s">&#39;proportional&#39;</span><span class="p">,</span> 
                                           <span class="n">ticks</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">boundaries</span><span class="o">=</span><span class="n">bounds</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Lithology&#39;</span><span class="p">,</span>
                                           <span class="n">orientation</span> <span class="o">=</span> <span class="s">&#39;horizontal&#39;</span><span class="p">)</span> <span class="c"># , format=&#39;%s&#39;)</span>
                
            <span class="k">else</span><span class="p">:</span> <span class="c"># default is vertical </span>
                <span class="c"># create a second axes for the colorbar</span>
                <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.165</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.69</span><span class="p">])</span>
                <span class="n">cb</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colorbar</span><span class="o">.</span><span class="n">ColorbarBase</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap_type</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="s">&#39;proportional&#39;</span><span class="p">,</span> 
                                           <span class="n">ticks</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">boundaries</span><span class="o">=</span><span class="n">bounds</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;Lithology&#39;</span><span class="p">,</span>
                                           <span class="n">orientation</span> <span class="o">=</span> <span class="s">&#39;vertical&#39;</span><span class="p">)</span> <span class="c"># , format=&#39;%s&#39;)</span>
            <span class="c"># define the bins and normalize</span>
    
            <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;layer_labels&quot;</span><span class="p">):</span>
                <span class="n">cb</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">kwds</span><span class="p">[</span><span class="s">&quot;layer_labels&quot;</span><span class="p">])</span>
                
            <span class="c"># invert axis to have &quot;correct&quot; stratigraphic order</span>
            <span class="n">cb</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_axis</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ax</span>
        <span class="k">elif</span> <span class="n">savefig</span><span class="p">:</span>
            <span class="n">fig_filename</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;fig_filename&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">_section_</span><span class="si">%s</span><span class="s">_pos_</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">cell_pos</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fig_filename</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s">&quot;tight&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            </div>
<div class="viewcode-block" id="NoddyOutput.export_to_vtk"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyOutput.export_to_vtk">[docs]</a>    <span class="k">def</span> <span class="nf">export_to_vtk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Export model to VTK</span>
<span class="sd">        </span>
<span class="sd">        Export the geology blocks to VTK for visualisation of the entire 3-D model in an</span>
<span class="sd">        external VTK viewer, e.g. Paraview.</span>
<span class="sd">        </span>
<span class="sd">        ..Note:: Requires pyevtk, available for free on: https://github.com/firedrakeproject/firedrake/tree/master/python/evtk</span>
<span class="sd">        </span>
<span class="sd">        **Optional keywords**:</span>
<span class="sd">            - *vtk_filename* = string : filename of VTK file (default: output_name)</span>
<span class="sd">            - *data* = np.array : data array to export to VKT (default: entire block model)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vtk_filename</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;vtk_filename&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basename</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">evtk.hl</span> <span class="kn">import</span> <span class="n">gridToVTK</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pyevtk.hl</span> <span class="kn">import</span> <span class="n">gridToVTK</span>
        <span class="c"># Coordinates</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent_x</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">delx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent_y</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dely</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dely</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent_z</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">delz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        
        <span class="c"># self.block = np.swapaxes(self.block, 0, 2)</span>
        
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;data&quot;</span><span class="p">):</span>
            <span class="n">gridToVTK</span><span class="p">(</span><span class="n">vtk_filename</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cellData</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;data&quot;</span> <span class="p">:</span> <span class="n">kwds</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">]})</span>         
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gridToVTK</span><span class="p">(</span><span class="n">vtk_filename</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cellData</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;geology&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">})</span>         
        </div></div>
<div class="viewcode-block" id="NoddyGeophysics"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyGeophysics">[docs]</a><span class="k">class</span> <span class="nc">NoddyGeophysics</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Definition to read, analyse, and visualise calculated geophysical responses&quot;&quot;&quot;</span>
     
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Methods to read, analyse, and visualise calculated geophysical responses</span>
<span class="sd">         </span>
<span class="sd">        .. note:: The geophysical responses have can be computed with a keyword in the</span>
<span class="sd">        function `compute_model`, e.g.:</span>
<span class="sd">        ``pynoddy.compute_model(history_name, output, type = &#39;GEOPHYSICS&#39;)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">=</span> <span class="n">output_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_gravity</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_magnetics</span><span class="p">()</span>
         
<div class="viewcode-block" id="NoddyGeophysics.read_gravity"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyGeophysics.read_gravity">[docs]</a>    <span class="k">def</span> <span class="nf">read_gravity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read calculated gravity response&quot;&quot;&quot;</span>
        <span class="n">grv_lines</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;.grv&quot;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grv_header</span> <span class="o">=</span> <span class="n">grv_lines</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span>
        <span class="c"># read in data</span>
        <span class="c"># print len(grv_lines) - 8</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grv_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grv_lines</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grv_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grv_lines</span><span class="p">[</span><span class="mi">8</span><span class="p">:]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grv_data</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)])</span>
            </div>
<div class="viewcode-block" id="NoddyGeophysics.read_magnetics"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyGeophysics.read_magnetics">[docs]</a>    <span class="k">def</span> <span class="nf">read_magnetics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read caluclated magnetic field response&quot;&quot;&quot;</span>
        <span class="n">mag_lines</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;.mag&quot;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mag_header</span> <span class="o">=</span> <span class="n">mag_lines</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span>
        <span class="c"># read in data</span>
        <span class="c"># print len(mag_lines) - 8</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_lines</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mag_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mag_lines</span><span class="p">[</span><span class="mi">8</span><span class="p">:]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mag_data</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)])</span>

</div></div>
<div class="viewcode-block" id="NoddyTopology"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology">[docs]</a><span class="k">class</span> <span class="nc">NoddyTopology</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;Definition to read, analyse, and visualise calculated voxel topology&quot;&quot;&quot;</span>        
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noddy_model</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Methods to read, analyse, and visualise calculated voxel topology</span>
<span class="sd">        .. note:: The voxel topology have can be computed with a keyword in the</span>
<span class="sd">        function `compute_model`, e.g.: ``pynoddy.compute_model(history_name, output, type = &#39;TOPOLOGY&#39;)``</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**</span>
<span class="sd">         - *noddy_model* = the name of the .his file or noddy output to run topology on.</span>
<span class="sd">         </span>
<span class="sd">         **Optional Keywords**</span>
<span class="sd">          - *load_attributes* = True if nodes and edges in the topology network should be attributed with properties such as volume</span>
<span class="sd">                               and surface area and lithology colour. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c">#if a .his file is passed strip extension</span>
        <span class="k">if</span> <span class="s">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">noddy_model</span><span class="p">:</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="n">noddy_model</span><span class="o">.</span><span class="n">split</span><span class="p">[</span><span class="s">&#39;.&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c">#remove file extension</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="n">noddy_model</span>
            
        <span class="c">#load model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">=</span> <span class="n">output_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_attributes</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;load_attributes&quot;</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="c">#load network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadNetwork</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;overall&quot;</span>
<div class="viewcode-block" id="NoddyTopology.loadNetwork"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.loadNetwork">[docs]</a>    <span class="k">def</span> <span class="nf">loadNetwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Loads the topology network into a NetworkX datastructure</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c">#import networkx</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Warning: NetworkX module could not be loaded. Please install NetworkX from https://networkx.github.io/ to perform topological analyses in PyNoddy&quot;</span>
        
        <span class="c">#initialise new networkX graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basename</span>

        <span class="c">#check files exist:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span><span class="o">+</span><span class="s">&quot;.g23&quot;</span><span class="p">):</span> <span class="c">#ensure topology code has been run</span>
            <span class="n">pynoddy</span><span class="o">.</span><span class="n">compute_topology</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span><span class="p">)</span>
        
        <span class="c">#load lithology properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_properties</span><span class="p">()</span>
               
        <span class="c">#load graph</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;.g23&quot;</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span> <span class="c">#read lines</span>
        
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span> <span class="c">#load edges</span>
            <span class="k">if</span> <span class="s">&#39;_&#39;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span> <span class="c">#this line contains topology stuff (aka ignore empty lines)</span>
                <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                <span class="n">data</span><span class="o">=</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">)</span>
                
                <span class="c">#calculate edge colors</span>
                <span class="n">topoCode1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">topoCode2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">lithoCode1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">lithoCode2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c">#number of voxels with this neighbour relationship (proxy of surface area)</span>
                
                <span class="c">#calculate edge type (dyke, fault etc)</span>
                <span class="n">eCode</span><span class="o">=</span><span class="mi">0</span>
                <span class="n">eAge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lithology_properties</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode1</span><span class="p">)][</span><span class="s">&#39;age&#39;</span><span class="p">]</span> <span class="c">#for original stratigraphy. Default is the age of the first node</span>
                <span class="n">eType</span> <span class="o">=</span> <span class="s">&#39;stratigraphic&#39;</span> <span class="c">#default is stratigraphy</span>
                <span class="n">eColour</span><span class="o">=</span><span class="s">&#39;grey&#39;</span> <span class="c">#black</span>
                <span class="c">#calculate new topology codes</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#default name is first name in sequence</span>
                
                
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">topoCode1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span> <span class="c">#-1 removes the trailing character</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">topoCode1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">topoCode2</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span> <span class="c">#find the difference</span>
                        <span class="c">#this is the &#39;age&#39; of this edge, as the lithologies formed during</span>
                        <span class="c">#different events</span>
                        <span class="n">eAge</span> <span class="o">=</span> <span class="n">i</span>
                        
                        <span class="c">#calculate what the difference means (ie. edge type)</span>
                        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">topoCode2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">topoCode1</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                            <span class="n">eCode</span><span class="o">=</span><span class="n">topoCode2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                           <span class="n">eCode</span><span class="o">=</span><span class="n">topoCode1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                           
                        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c">#calculate event name</span>
                        
                        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">eCode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c">#stratigraphic contact</span>
                            <span class="n">eColour</span> <span class="o">=</span> <span class="s">&#39;grey&#39;</span>
                            <span class="n">eType</span> <span class="o">=</span> <span class="s">&#39;stratigraphic&#39;</span>
                        <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">eCode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="n">eCode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="n">eCode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span> <span class="c">#various types of faults</span>
                            <span class="n">eColour</span> <span class="o">=</span> <span class="s">&#39;r&#39;</span> <span class="c">#red</span>
                            <span class="n">eType</span> <span class="o">=</span> <span class="s">&#39;fault&#39;</span>
                        <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">eCode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c">#unconformity</span>
                            <span class="n">eColour</span> <span class="o">=</span> <span class="s">&#39;g&#39;</span> <span class="c">#green</span>
                            <span class="n">eType</span> <span class="o">=</span> <span class="s">&#39;unconformity&#39;</span>
                        <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">eCode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span> <span class="c">#plug/dyke</span>
                            <span class="n">eColour</span> <span class="o">=</span> <span class="s">&#39;orange&#39;</span> <span class="c">#orange</span>
                            <span class="n">eType</span> <span class="o">=</span> <span class="s">&#39;intrusive&#39;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">eColour</span> <span class="o">=</span> <span class="s">&#39;y&#39;</span> <span class="c">#yellow</span>
                            <span class="n">eType</span> <span class="o">=</span> <span class="s">&#39;unknown&#39;</span> 
                
                <span class="c">#create nodes &amp; associated properties</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lithology</span><span class="o">=</span><span class="n">lithoCode1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lithology_properties</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode1</span><span class="p">)][</span><span class="s">&#39;name&#39;</span><span class="p">],</span> <span class="n">age</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lithology_properties</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode1</span><span class="p">)][</span><span class="s">&#39;age&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">lithology</span><span class="o">=</span><span class="n">lithoCode2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lithology_properties</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode2</span><span class="p">)][</span><span class="s">&#39;name&#39;</span><span class="p">],</span> <span class="n">age</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lithology_properties</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode2</span><span class="p">)][</span><span class="s">&#39;age&#39;</span><span class="p">])</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">load_attributes</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;colour&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lithology_properties</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode1</span><span class="p">)][</span><span class="s">&#39;colour&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node_properties</span><span class="p">[</span><span class="s">&quot;</span><span class="si">%d</span><span class="s">_</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode1</span><span class="p">),</span><span class="n">topoCode1</span><span class="p">)</span> <span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_properties</span><span class="p">[</span><span class="s">&quot;</span><span class="si">%d</span><span class="s">_</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode1</span><span class="p">),</span><span class="n">topoCode1</span><span class="p">)</span> <span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;colour&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lithology_properties</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode2</span><span class="p">)][</span><span class="s">&#39;colour&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node_properties</span><span class="p">[</span> <span class="s">&quot;</span><span class="si">%d</span><span class="s">_</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode2</span><span class="p">),</span><span class="n">topoCode2</span><span class="p">)</span> <span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_properties</span><span class="p">[</span> <span class="s">&quot;</span><span class="si">%d</span><span class="s">_</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">lithoCode2</span><span class="p">),</span><span class="n">topoCode2</span><span class="p">)</span> <span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span>
               
                <span class="c">#add edge</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span><span class="n">edgeCode</span><span class="o">=</span><span class="n">eCode</span><span class="p">,</span><span class="n">edgeType</span><span class="o">=</span><span class="n">eType</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="n">eColour</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="n">eAge</span><span class="p">)</span>
                </div>
<div class="viewcode-block" id="NoddyTopology.read_properties"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.read_properties">[docs]</a>    <span class="k">def</span> <span class="nf">read_properties</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
                    
        <span class="c">#load lithology colours &amp; relative ages. There is some duplication here</span>
        <span class="c">#of the NoddyOutput (sloppy, I know...) - ideally I should implement a base class </span>
        <span class="c">#that does this stuff and NoddyOutput and NoddyTopology both inherit from....</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;.g20&quot;</span><span class="p">):</span>
            <span class="n">filelines</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;.g20&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_events</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">filelines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span> <span class="c">#number of events</span>
            <span class="n">lithos</span> <span class="o">=</span> <span class="n">filelines</span><span class="p">[</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_events</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">filelines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="c">#litho definitions</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">rock_ids</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#list of litho ids. Will be a list from 1 to n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rock_names</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#the (string) names of each rock type. Note that names including spaces will not be read properly.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rock_colors</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#the colours of each rock type (in Noddy).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rock_events</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#list of the events that created different lithologies</span>
            
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lithos</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rock_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rock_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rock_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rock_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span><span class="o">/</span><span class="mf">255.</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mf">255.</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">255.</span><span class="p">)</span> <span class="p">)</span>
            
            <span class="c">#load last line (list of names)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">event_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">filelines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">)</span>
        
            <span class="c">#calculate stratigraphy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stratigraphy</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#litho id&#39;s ordered by the age they were created in</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rock_events</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c">#loop through events</span>
                <span class="c">#create list of lithos created in this event</span>
                <span class="n">lithos</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rock_events</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span> <span class="c">#current event</span>
                        <span class="n">lithos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rock_ids</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                
                <span class="c">#reverse order... Noddy litho id&#39;s are ordered by event, but reverse ordered within depositional events (ie.</span>
                <span class="c">#lithologies created in younger events have larger ids, however the youngest unit created in a given event</span>
                <span class="c">#will have the smallest id...</span>
                
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">lithos</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stratigraphy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            
        <span class="c">#create property dict for easier access to attributes from node codes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lithology_properties</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rock_ids</span><span class="p">:</span> <span class="c">#litho codes</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">params</span><span class="p">[</span><span class="s">&#39;code&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>
            <span class="n">params</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rock_names</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">params</span><span class="p">[</span><span class="s">&#39;colour&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rock_colors</span><span class="p">[</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">]</span>
            <span class="n">params</span><span class="p">[</span><span class="s">&#39;age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stratigraphy</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">lithology_properties</span><span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="s">&#39;code&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">params</span>
            
        <span class="c">#f = open(self.basename + &quot;.g20&quot;, &#39;r&#39;)</span>
        <span class="c">#lines = f.readlines()   </span>
        <span class="c">#for i in range(self.n_events + 3,len(lines)-1): #loop through lithology definitions</span>
        <span class="c">#    l = (lines[i].strip()).split(&#39; &#39;)</span>
        
        <span class="c">#    #load lithology parameters</span>
        <span class="c">#    params = {}</span>
        <span class="c">#    params[&#39;code&#39;] = int(l[0])</span>
        <span class="c">#    params[&#39;name&#39;] = &#39; &#39;.join(l[2:-3])</span>
            
        <span class="c">#    #colours are the last 3 values</span>
        <span class="c">#    params[&#39;colour&#39;] = [ float(l[-3]) / 255.0, float(l[-2]) / 255.0, float(l[-1]) / 255.0 ]</span>
        
        <span class="c">#    #store lithology parameters (using lithocode as key)</span>
        <span class="c">#    self.lithology_properties[params[&#39;code&#39;]] = params          </span>
                
        <span class="c">#load node locations from .vs file</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">load_attributes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_properties</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;_v.vs&quot;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="k">if</span> <span class="s">&quot;PVRTX&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span> <span class="c">#this is a vertex</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">params</span><span class="p">[</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
                    <span class="n">params</span><span class="p">[</span><span class="s">&#39;litho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                    <span class="n">params</span><span class="p">[</span><span class="s">&#39;topo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
                    <span class="n">params</span><span class="p">[</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="c">#number of voxels of this type</span>
                    
                    <span class="c">#save (key = LITHO_TOPO (eg. 2_001a))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">node_properties</span><span class="p">[</span> <span class="s">&#39;</span><span class="si">%d</span><span class="s">_</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s">&#39;litho&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s">&#39;topo&#39;</span><span class="p">])</span> <span class="p">]</span> <span class="o">=</span> <span class="n">params</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="NoddyTopology.read_adjacency_matrix"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.read_adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">read_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;**DEPRECIATED**</span>
<span class="sd">        Read max number of lithologies aross all models&quot;&quot;&quot;</span>
        <span class="n">ml_lines</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;.g22&quot;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="c"># read in data</span>
        
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">ml_lines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxlitho</span> <span class="o">=</span> <span class="n">line</span> 
            
        <span class="k">print</span> <span class="s">&quot;maxlitho =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxlitho</span>
    </div>
<div class="viewcode-block" id="NoddyTopology.filter_node_volumes"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.filter_node_volumes">[docs]</a>    <span class="k">def</span> <span class="nf">filter_node_volumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">min_volume</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Removes all nodes with volumes less than the specified size</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">         - *min_volume* = the threshold volume. Nodes with smaller volumes are deleted.</span>
<span class="sd">         </span>
<span class="sd">        **Returns**</span>
<span class="sd">         - returns the number of deleted nodes</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_volume</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">count</span>
        </div>
<div class="viewcode-block" id="NoddyTopology.collapse_stratigraphy"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.collapse_stratigraphy">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_stratigraphy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Collapses all stratigraphic edges in this network to produce a network that only contains</span>
<span class="sd">        structurally bound rock volumes. Essentially this is a network built only with Topology codes</span>
<span class="sd">        and ignoring lithology</span>
<span class="sd">        </span>
<span class="sd">        **Returns**</span>
<span class="sd">         - a new NoddyTopology object containing the collapsed graph. The original object is not modified.</span>
<span class="sd">        &#39;&#39;&#39;</span>  
        
        <span class="c">#check we can</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;overall&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Error: structural and lithological collapsed topologies can only be calculated from the overall topology&quot;</span>
            <span class="k">return</span>
            
        <span class="c">#make copy of this object</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="n">topo</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;structural&quot;</span>
        
        <span class="c">#retrieve list of edges, ignoring lithology</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">code1</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="c">#topology code of node 1</span>
            <span class="n">code2</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="c">#topology code of node 2</span>
            
            <span class="c">#change code1 &amp; code2 endings 2 a (discrete volumes don&#39;t mean anything anymore)</span>
            <span class="n">code1</span> <span class="o">=</span> <span class="n">code1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;A&#39;</span> <span class="c">#retain last letter for compatability/concistency...</span>
            <span class="n">code2</span> <span class="o">=</span> <span class="n">code2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;A&#39;</span>
            
            
            <span class="c">#add edge tuple to edges array</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">code1</span><span class="p">,</span><span class="n">code2</span><span class="p">,</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">)</span>
            
                    
        <span class="c">#remake graph</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        
        <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        
        <span class="c">#remove self loops</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span> <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">selfloop_edges</span><span class="p">()</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">topo</span>
       </div>
<div class="viewcode-block" id="NoddyTopology.collapse_structure"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.collapse_structure">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Collapses all topology codes down to the last (most recent) difference. Information regarding specific model topology is </span>
<span class="sd">        generalised, eg. lithology A has a fault and stratigrappic contact with B (regardless of how many different faults are involved).</span>
<span class="sd">                </span>
<span class="sd">        **Optional Arguments**:</span>
<span class="sd">         - *verbose* = True if this function should write to the print buffer. Default is False.</span>
<span class="sd">        **Returns**</span>
<span class="sd">         - a new NoddyTopology object containing the collapsed graph. The original object is not modified.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c">#check we can</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;overall&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Error: structural and lithological collapsed topologies can only be calculated from the overall topology&quot;</span>
            <span class="k">return</span>
            
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="n">topo</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;stratigraphic&quot;</span>
        
        <span class="c">#clear the graph in topo</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        
        <span class="c">#loop through graph</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="c">#get lithology code</span>
            <span class="n">lith1</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#lithology code of node1</span>
            <span class="n">lith2</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#lithology code of node2</span>
            
            <span class="c">#calculate new node tags (based entirely on lithology)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lith1</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lith2</span><span class="p">)</span>
            
            <span class="c">#update attributes of u</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">u</span><span class="p">):</span> <span class="c">#new node, add</span>
                <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">age</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;age&#39;</span><span class="p">],</span>
                                      <span class="n">colour</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;colour&#39;</span><span class="p">],</span>
                                      <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;name&#39;</span><span class="p">],</span>
                                      <span class="n">volume</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;volume&#39;</span><span class="p">],</span>
                                      <span class="n">lithology</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;lithology&#39;</span><span class="p">])</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="c">#increment volume</span>
            
            <span class="c">#do the same for v</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">v</span><span class="p">):</span> <span class="c">#new node, add</span>
                <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">age</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;age&#39;</span><span class="p">],</span>
                                     <span class="n">colour</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;colour&#39;</span><span class="p">],</span>
                                     <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;name&#39;</span><span class="p">],</span>
                                     <span class="n">volume</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;volume&#39;</span><span class="p">],</span>
                                     <span class="n">lithology</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;lithology&#39;</span><span class="p">])</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="c">#increment volume</span>
            
            
            <span class="c">#generate edges</span>
            <span class="k">if</span> <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span> <span class="c">#edge already exists</span>
                <span class="c">#do our best to append/merge attributes</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">key</span><span class="p">])</span> <span class="c">#increment numbers</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span><span class="ne">TypeError</span><span class="p">):</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">key</span><span class="p">])</span> <span class="c">#try appending (for lists)</span>
                            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="p">]</span> <span class="c">#make list</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="c">#key not found, add new key</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c">#create new edge</span>
                <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">attr_dict</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="s">&quot;Collapsed (</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">) to (</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">topo</span></div>
<div class="viewcode-block" id="NoddyTopology.jaccard_coefficient"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.jaccard_coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">jaccard_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates the Jaccard Coefficient (ratio between the intersection &amp; union) of the graph representing this NOddyTopology and G2.</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**</span>
<span class="sd">         - *G2* = a valid NoddyTopology object or NetworkX graph that this topology is to be compared with</span>
<span class="sd">         </span>
<span class="sd">        **Returns**</span>
<span class="sd">          - The jaccard_coefficient</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c">#intersection is initially zero</span>
        <span class="n">intersection</span><span class="o">=</span><span class="mi">0</span>
        
        <span class="c">#ensure G2 is a graph object</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span><span class="n">NoddyTopology</span><span class="p">):</span>
            <span class="n">G2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">graph</span> <span class="c">#we want the graph bit</span>
        
        <span class="c">#ensure we are not comparing two empty graphs</span>
        <span class="k">if</span> <span class="n">G2</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Warning: comparing two empty graphs... </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">G2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>            
            <span class="k">return</span> <span class="mi">1</span> <span class="c">#two null graphs should be the same</span>
            
        <span class="c">#add edges from this graph to union</span>
        <span class="n">union</span><span class="o">=</span><span class="n">G2</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span> <span class="c">#edge present in both graphs</span>
                <span class="n">intersection</span><span class="o">+=</span><span class="mi">1</span> <span class="c">#add this edge to intersection</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">union</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c">#edge is new, add to union</span>
        
        <span class="k">return</span> <span class="n">intersection</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">union</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NoddyTopology.is_unique"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.is_unique">[docs]</a>    <span class="k">def</span> <span class="nf">is_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">known</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns True if the topology of this model is different (ie. forms a different network) to a list of models.</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">            -*known* = a list of valid NoddyTopology objects or NetworkX graphs to compare with.</span>
<span class="sd">        </span>
<span class="sd">        **Returns**:</span>
<span class="sd">         - Returns true if this topology is unique, otherwise false</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">g2</span> <span class="ow">in</span> <span class="n">known</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaccard_coefficient</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span> <span class="c">#the models match</span>
        <span class="k">return</span> <span class="bp">True</span>
    </div>
<div class="viewcode-block" id="NoddyTopology.find_first_match"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.find_first_match">[docs]</a>    <span class="k">def</span> <span class="nf">find_first_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">known</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Identical to is_unique, except that the index of the first match is returned if this matches, otherwise</span>
<span class="sd">        -1 is returned.</span>
<span class="sd">        **Arguments**:</span>
<span class="sd">            -*known* = a list of valid NoddyTopology objects or NetworkX graphs to compare with.</span>
<span class="sd">        </span>
<span class="sd">        **Returns**:</span>
<span class="sd">         - Returns the index of the first matching topology object, or -1</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">index</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">g2</span> <span class="ow">in</span> <span class="n">known</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaccard_coefficient</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">index</span> <span class="c">#the models match</span>
            <span class="n">index</span><span class="o">+=</span><span class="mi">1</span>
            
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    
    </div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="NoddyTopology.combine_topologies"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.combine_topologies">[docs]</a>    <span class="k">def</span> <span class="nf">combine_topologies</span><span class="p">(</span><span class="n">topology_list</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Combines a list of topology networks into a weighted &#39;super-network&#39;. This is designed for</span>
<span class="sd">        estimating the likelyhood of a given edge occuring using a series of networks generated in</span>
<span class="sd">        a Monte-Carlo type analysis.</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**</span>
<span class="sd">         - *topology_list* = A list of networkX graphs or NoddyTopology objects to build supernetwork from.</span>
<span class="sd">        **Returns**</span>
<span class="sd">         - A NetworkX graph object containing all edges from the input graphs and weighted (&#39;weight&#39; parameter)</span>
<span class="sd">           according to their observed frequency.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c">#validate input</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">topology_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Topology list contains no topologies... cannot combine.&quot;</span>
            <span class="k">return</span>
        
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
        
        <span class="n">S</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        
        <span class="n">w_inc</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">topology_list</span><span class="p">)</span> <span class="c">#the amount weights go up per edge.</span>
                                        <span class="c">#if an edge is observed in every topology, then</span>
                                        <span class="c">#the weight == 1</span>
        
        <span class="c">#copy nodes from all networks in topology_list into S</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="k">for</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">topology_list</span><span class="p">:</span>
            <span class="c">#ensure G is a Graph</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">NoddyTopology</span><span class="p">):</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span> <span class="c">#we want the graph bit</span>
        
            <span class="c">#loop through nodes and average/append them</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                 <span class="c">#Node 1</span>
                 <span class="k">if</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                     <span class="n">S</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">attr_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
                     
                     <span class="c">#cast variables to list (or tuple of lists from centroid)</span>
                     <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;volume&#39;</span><span class="p">):</span>
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]]</span> 
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">w_inc</span>
                     <span class="k">else</span><span class="p">:</span>
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                         
                     <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;centroid&#39;</span><span class="p">):</span>
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]],[</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]],[</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>                     
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_inc</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">w_inc</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">w_inc</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                 <span class="k">else</span><span class="p">:</span> <span class="c">#node already exists, store attributes</span>
                     
                     <span class="c">#append centroid</span>
                     <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;centroid&#39;</span><span class="p">):</span>
                         <span class="n">c1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span>
                         
                         <span class="c">#list of all centroids</span>
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid_list&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid_list&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid_list&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                         
                         <span class="c">#average centroid</span>
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">w_inc</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                  <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">w_inc</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                  <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">w_inc</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                         
                 
                     <span class="c">#append volume</span>
                     <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;volume&#39;</span><span class="p">):</span>
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume_list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">])</span>
                     
                         <span class="c">#add to average</span>
                         <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">w_inc</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;volume&#39;</span><span class="p">]</span>
          
        <span class="c">#now copy edges across and average/append them</span>
        <span class="k">for</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">topology_list</span><span class="p">:</span>
            
            <span class="c">#ensure G is a Graph</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">NoddyTopology</span><span class="p">):</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span> <span class="c">#we want the graph bit</span>
                
            <span class="c">#loop through edges</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>                 
                 <span class="c">#average/add edges</span>
                 <span class="k">if</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="c">#add new edge</span>
                     <span class="c">#add edge</span>
                     <span class="n">S</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                     
                     <span class="n">s_e</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                     <span class="n">s_e</span><span class="p">[</span><span class="s">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_inc</span>
                     
                     <span class="c">#cast vars to list</span>
                     <span class="n">s_e</span><span class="p">[</span><span class="s">&#39;area_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s_e</span><span class="p">[</span><span class="s">&#39;area&#39;</span><span class="p">]]</span>
                     <span class="k">try</span><span class="p">:</span>
                         <span class="n">s_e</span><span class="p">[</span><span class="s">&#39;area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_e</span><span class="p">[</span><span class="s">&#39;area&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">w_inc</span>
                     <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                         <span class="k">print</span> <span class="s">&quot;Type error combining edge </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">. List was observed rather than float - </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">str</span><span class="p">(</span><span class="n">s_e</span><span class="p">[</span><span class="s">&#39;area&#39;</span><span class="p">]))</span>
                                          
                 <span class="k">else</span><span class="p">:</span> <span class="c">#edge already exists</span>
                     
                     <span class="c">#append/average attributes</span>
                     <span class="n">s_e</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                     <span class="n">s_e</span><span class="p">[</span><span class="s">&#39;area_list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;area&#39;</span><span class="p">])</span> <span class="c">#store area</span>
                     <span class="n">s_e</span><span class="p">[</span><span class="s">&#39;area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_e</span><span class="p">[</span><span class="s">&#39;area&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;area&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">w_inc</span> <span class="c">#average area</span>
                     
                     <span class="c">#increment weight</span>
                     <span class="n">s_e</span><span class="p">[</span><span class="s">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_e</span><span class="p">[</span><span class="s">&#39;weight&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">w_inc</span> 
                     
        
        <span class="c">#return the graph</span>
        <span class="k">return</span> <span class="n">S</span>
    </div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="NoddyTopology.calculate_unique_topologies"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.calculate_unique_topologies">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_unique_topologies</span><span class="p">(</span><span class="n">topology_list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates the number of unique topologies in a list of NoddyTopologies</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">         - *topology_list* = The list of NoddyTopologies to search through.</span>
<span class="sd">         </span>
<span class="sd">        **Optional Keywords**:</span>
<span class="sd">         - *output* = A File or list to write cumulative observed topologies distribution. Default is None (nothing written).</span>
<span class="sd">         - *ids* = A list to write the unique topology id&#39;s for each topology in the provided topology_list (in that </span>
<span class="sd">                     order). Default is None.</span>
<span class="sd">         - *frequency* = A list to write frequency counts to. </span>
<span class="sd">        **Returns**:</span>
<span class="sd">         - Returns a list of unique topologies.</span>
<span class="sd">       &#39;&#39;&#39;</span>
        
        <span class="n">output</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;output&quot;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;ids&quot;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">frequency</span><span class="o">=</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;frequency&quot;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        
        <span class="n">out_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">uTopo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">topology_list</span><span class="p">:</span>
            <span class="n">i</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">find_first_match</span><span class="p">(</span><span class="n">uTopo</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span> <span class="c">#this is a new topology</span>
                <span class="c">#t.filter_node_volumes(50)</span>
                <span class="n">uTopo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">frequency</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">frequency</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c">#this topology has been observed once</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ids</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c">#store new id</span>
                    <span class="n">ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uTopo</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    
            <span class="k">else</span><span class="p">:</span> <span class="c">#this topology has been seen before</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">frequency</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c">#increase frequency</span>
                    <span class="n">frequency</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> 
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ids</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c">#store retrieved id</span>
                    <span class="n">ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            
            
            <span class="c">#store cumulative output</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uTopo</span><span class="p">))</span>
                            
        <span class="c">#write output file if necessary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">types</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">StringType</span><span class="p">:</span> <span class="c">#path has been given so write file</span>
                
                <span class="c">#check directory exists</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">output</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
                <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
                
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">o</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">ListType</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">uTopo</span>
       </div>
<div class="viewcode-block" id="NoddyTopology.calculate_overlap"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.calculate_overlap">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates the overlap between this NoddyTopology and another NoddyTopology or networkX graph</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**</span>
<span class="sd">         - *G2* = a valid NoddyTopology object or NetworkX graph that this topology is to be compared with</span>
<span class="sd">         </span>
<span class="sd">        **Returns**</span>
<span class="sd">          - The number of overlapping edges </span>
<span class="sd">          - A list of these edges</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c">#ensure G2 is a graph object</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span><span class="n">NoddyTopology</span><span class="p">)):</span>
            <span class="n">G2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">graph</span> <span class="c">#we want the graph bit</span>
        
        <span class="n">similarity</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">edges</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="n">similarity</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">similarity</span><span class="p">,</span> <span class="n">edges</span>
        </div>
<div class="viewcode-block" id="NoddyTopology.calculate_difference"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.calculate_difference">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G2</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates the difference between this NoddyTopology and another NoddyTopology or networkX graph</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**</span>
<span class="sd">         - *G2* = a valid NoddyTopology object or NetworkX graph that this topology is to be compared with</span>
<span class="sd">         </span>
<span class="sd">        **Returns**</span>
<span class="sd">          A tuple containing:</span>
<span class="sd">          - The number of different edges </span>
<span class="sd">          - a list of these edges</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c">#ensure G2 is a graph object</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span><span class="n">NoddyTopology</span><span class="p">)):</span>
            <span class="n">G2</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">graph</span> <span class="c">#we want the graph bit</span>
            
        <span class="n">difference</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">edges</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="c">#check for edges this object has but G2 does not</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">G2</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span> <span class="c">#this is a difference</span>
                <span class="n">difference</span><span class="o">+=</span><span class="mi">1</span>
                
                <span class="c">#store comparator ids</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">+=</span> <span class="p">({</span><span class="s">&#39;comp_id&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">},)</span> <span class="c">#this is from the initial topology</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;comp_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        
        <span class="c">#check for any edges that G2 has but this object does not</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G2</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">difference</span><span class="o">+=</span><span class="mi">1</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">+=</span> <span class="p">({</span><span class="s">&#39;comp_id&#39;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">},)</span> <span class="c">#this is from the initial topology</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;comp_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">difference</span><span class="p">,</span><span class="n">edges</span>
        </div>
<div class="viewcode-block" id="NoddyTopology.find_matching"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.find_matching">[docs]</a>    <span class="k">def</span> <span class="nf">find_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">known</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Finds the first matching NoddyTopology (or NetworkX graph) in the specified list</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">            -*known* = a list of valid NoddyTopology objects or NetworkX graphs to compare with.</span>
<span class="sd">        </span>
<span class="sd">        **Returns**:</span>
<span class="sd">         - Returns the first matching object (jaccard coefficient = 1), or otherwise None</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">g1</span> <span class="ow">in</span> <span class="n">known</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaccard_coefficient</span><span class="p">(</span><span class="n">g1</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">g1</span> <span class="c">#return the match</span>
        <span class="k">return</span> <span class="bp">None</span> <span class="c">#no match</span>
        </div>
<div class="viewcode-block" id="NoddyTopology.write_summary_file"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.write_summary_file">[docs]</a>    <span class="k">def</span> <span class="nf">write_summary_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Writes summary information about this network to a file</span>
<span class="sd">        </span>
<span class="sd">        **Optional Arguments**</span>
<span class="sd">         - *append* = True if summary information should be appended to the file. If so the file is written as a csv spreadsheet. </span>
<span class="sd">                      Default is true. If False is passed, a single, detailed summary is written for this network.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span> <span class="c">#write summary information in spreadsheet formant</span>
            <span class="n">exists</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">:</span> <span class="c">#write header</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;name,#nodes,#edges</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="c">#todo add other stuff here</span>
                
            <span class="c">#write data</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()))</span>
        
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span> <span class="c">#write detailed information</span>
            <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
            
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Summary:&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Name: </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">basename</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;#nodes: </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">())</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;#edges: </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">())</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Detail&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Degree sequence: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Node list: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">False</span><span class="p">)))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Edge list: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">False</span><span class="p">)))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Node attributes: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">)))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Edge attributes: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">)))</span>
            
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
       </div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="NoddyTopology.draw_graph_matrix"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.draw_graph_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">draw_graph_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draws an adjacency matrix representing the specified graph object. Equivalent to</span>
<span class="sd">        NoddyTopology.draw_matrix_image() but for a networkX graph object.</span>
<span class="sd">        </span>
<span class="sd">        **Keywords**:</span>
<span class="sd">         - *strat* = A dictionary linking node names to stratigraphic heights and names. Should be as follows { node_name : (height,name) }.</span>
<span class="sd">         - *path* = The path to save this image to. If not provided, the image is drawn to the screen</span>
<span class="sd">         - *dpi* = The resolution to save this image. Default is 300</span>
<span class="sd">         - *size* = The size of the image to save (in inches). This value will be used as the width and the height</span>
<span class="sd">         </span>
<span class="sd">         </span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
            <span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="kn">as</span> <span class="nn">patches</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Could not draw image as matplotlib is not installed. Please install matplotlib.&quot;</span>
            <span class="k">return</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        
        <span class="c">#retrieve data from network</span>
        <span class="n">nodes</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="c">#sort node list alphabetically first</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">))</span>
        
        <span class="c">#now sort by age, if we know it</span>
        <span class="k">if</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;age&#39;</span><span class="p">):</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;age&#39;</span><span class="p">])</span>
        
        <span class="c">#build node id dictionary mapping</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ids</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            
        <span class="c">#build matrix</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="p">[[(</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dots</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
                <span class="c">#calculate alpha</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;weight&#39;</span><span class="p">,</span><span class="mf">0.4</span><span class="p">)</span> <span class="c">#super networks will have a weight</span>
                                               <span class="c">#otherwise use 0.4</span>
        
                <span class="c">#store colours  (nb. matrix is symmetric, so operations are repeated)</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]][</span><span class="n">ids</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;colour&#39;</span><span class="p">],</span><span class="n">alpha</span><span class="p">)</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]][</span><span class="n">ids</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;colour&#39;</span><span class="p">],</span><span class="n">alpha</span><span class="p">)</span>
                
                <span class="c">#label info</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;colour&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="c">#add from list</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;colour&#39;</span><span class="p">])</span> <span class="p">):</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;colour&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;edgeType&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c">#add directly</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;colour&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;edgeType&#39;</span><span class="p">]</span>
                
                <span class="c">#save dots (for comparison matrices)</span>
                <span class="n">dots</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]][</span><span class="n">ids</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;comp_id&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="c">#default is no dot</span>
                <span class="n">dots</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]][</span><span class="n">ids</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;comp_id&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                
        <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c">#colour (single colour or list of colours if this is a lithological topology)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c">#alpha</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">):</span> <span class="c">#catch floating point errors</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.99999</span>
                
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span> <span class="c">#multiple relationships...</span>
                    <span class="c">#find unique relationships, in case they are repeated (though they should not be)</span>
                    <span class="n">unique</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique</span><span class="p">:</span>
                            <span class="n">unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    
                    <span class="c">#draw unique</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                            <span class="c">#draw patch</span>
                            <span class="n">patch</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span> 
                                            <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span>
                                            <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="n">a</span><span class="p">))</span>
                            <span class="n">patch</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span>
                            <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c">#draw two triangles</span>
                        <span class="c">#upper triangle</span>
                        <span class="n">upper</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
                                                <span class="n">xy</span><span class="o">=</span><span class="p">[[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span>
                                                <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="n">a</span><span class="p">))</span>
                        <span class="n">upper</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span>   
                        <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                        
                        <span class="c">#lower triangle</span>
                        <span class="n">lower</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
                                                <span class="n">xy</span><span class="o">=</span><span class="p">[[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">],[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span>
                                                <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="n">a</span><span class="p">))</span>
                        <span class="n">upper</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">)</span>   
                        <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                        
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c">#draw two triangles with circle</span>
                        <span class="c">#upper triangle</span>
                        <span class="n">upper</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
                                                <span class="n">xy</span><span class="o">=</span><span class="p">[[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span>
                                                <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="n">a</span><span class="p">))</span>
                        <span class="n">upper</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span>   
                        <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                        
                        <span class="c">#lower triangle</span>
                        <span class="n">lower</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
                                                <span class="n">xy</span><span class="o">=</span><span class="p">[[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">],[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span>
                                                <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="n">a</span><span class="p">))</span>
                        <span class="n">lower</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">)</span>   
                        <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                        
                        <span class="c">#circle</span>
                        <span class="n">circle</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span>
                                                <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="mf">0.25</span><span class="p">,</span>
                                                <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">circle</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="p">)</span>  
                        <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                        
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> <span class="c">#draw 4 boxes</span>
                        <span class="c">#upper left</span>
                        <span class="n">patch</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span> 
                                        <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span>
                                        <span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="n">a</span><span class="p">))</span>
                        <span class="n">patch</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                        
                        <span class="c">#upper right</span>
                        <span class="n">patch</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span> 
                                        <span class="p">(</span><span class="n">x</span><span class="o">+.</span><span class="mi">5</span><span class="p">,</span><span class="n">y</span><span class="p">),</span>
                                        <span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="n">a</span><span class="p">))</span>
                        <span class="n">patch</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">)</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                        <span class="c">#lower left</span>
                        <span class="n">patch</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span> 
                                        <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+.</span><span class="mi">5</span><span class="p">),</span>
                                        <span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="n">a</span><span class="p">))</span>
                        <span class="n">patch</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="p">)</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                        
                        <span class="c">#lower right</span>
                        <span class="n">patch</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span> 
                                        <span class="p">(</span><span class="n">x</span><span class="o">+.</span><span class="mi">5</span><span class="p">,</span><span class="n">y</span><span class="o">+.</span><span class="mi">5</span><span class="p">),</span>
                                        <span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">alpha</span><span class="o">=</span><span class="n">a</span><span class="p">))</span>
                        <span class="n">patch</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="p">)</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                                        
                        
                    <span class="k">else</span><span class="p">:</span> <span class="c">#uh oh - though tbh this *should* never happen.... (though Murphy would disagree)</span>
                        <span class="k">print</span> <span class="s">&quot;Error: more than 4 relationship types! This cannot be drawn on adjacency matrix&quot;</span>
                        <span class="k">print</span> <span class="n">c</span>                        
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span> <span class="c">#only one relationship, rectangular patch</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>     
                        <span class="c">#draw patch</span>
                        <span class="n">patch</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span> 
                                        <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span>
                                        <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">facecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">a</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span> <span class="c">#dot hatch</span>
                            <span class="n">patch</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span> 
                                            <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span>
                                            <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">,</span><span class="n">edgecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span><span class="n">hatch</span><span class="o">=</span><span class="s">&#39;.&#39;</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span> <span class="c">#cross hatch</span>
                            <span class="n">patch</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span> 
                                            <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span>
                                            <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span><span class="n">hatch</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">))</span>
                            
                        <span class="n">patch</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span> <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="p">)</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;_nolegend_&#39;</span> <span class="c">#so we don&#39;t show labels multiple times</span>
                        
                <span class="c">#draw dots</span>
                <span class="k">if</span> <span class="n">dots</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c">#draw dot</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
                    <span class="c">#print &quot;dot %d, %d&quot; % (x,y)</span>
                    
        <span class="c">#plot grid</span>
        <span class="c">#ax.grid()</span>
            
        <span class="c">#plot legend</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">borderaxespad</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>

        <span class="c">#set limits &amp; flip y</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="c">#ax.invert_yaxis()</span>
        
        <span class="c">#set ticks</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span> <span class="n">x</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span> <span class="n">y</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
        
        <span class="c">#build node name mapping</span>
        <span class="n">name_list</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#order list containing node names from 0 to n</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
                <span class="c">#name+=node[0].split(&#39;_&#39;)[-1]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="n">name_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">name_list</span><span class="p">,</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">name_list</span><span class="p">)</span>
        
        <span class="c">#set figure size</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;size&#39;</span><span class="p">,</span><span class="mf">5.</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_figwidth</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_figheight</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        
        <span class="c">#save/show</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;path&#39;</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">kwds</span><span class="p">[</span><span class="s">&#39;path&#39;</span><span class="p">],</span><span class="n">dpi</span><span class="o">=</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;dpi&#39;</span><span class="p">,</span><span class="mi">300</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                                                                                                                                                                                                                                                                                                          </div>
<div class="viewcode-block" id="NoddyTopology.draw_adjacency_matrix"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.draw_adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">draw_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draws an adjacency matrix representing this topology object.</span>
<span class="sd">        </span>
<span class="sd">        **Keywords**:</span>
<span class="sd">         - *path* = The path to save this image to. If not provided, the image is drawn to the screen</span>
<span class="sd">         - *dpi* = The resolution to save this image. Default is 300</span>
<span class="sd">         - *size* = The size of the image to save (in inches). This value will be used as the width and the height</span>
<span class="sd">         </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">NoddyTopology</span><span class="o">.</span><span class="n">draw_graph_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="NoddyTopology.draw_difference_matrix"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.draw_difference_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">draw_difference_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draws an adjacency matrix containing the difference between this topology and the provided topology</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**:</span>
<span class="sd">         - *G2* = A different NoddyTopology or NetworkX Graph to compare to</span>
<span class="sd">        </span>
<span class="sd">        **Optional Keywords**:</span>
<span class="sd">         - *strat* = A dictionary linking node names to stratigraphic heights and names. Should be as follows { node_name : (height,name) }.</span>
<span class="sd">         - *path* = The path to save this image to. If not provided, the image is drawn to the screen</span>
<span class="sd">         - *dpi* = The resolution to save this image. Default is 300</span>
<span class="sd">         - *size* = The size of the image to save (in inches). This value will be used as the width and the height</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c">#ensure G2 is a graph object</span>
        <span class="c">#if (isinstance(G2,NoddyTopology)):</span>
        <span class="c">#    G2 = G2.graph #we want the graph bit</span>
            
        <span class="c">#get difference</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">edge_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_difference</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="c">#make graph of difference</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">D</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
        
        <span class="c">#plot</span>
        <span class="n">NoddyTopology</span><span class="o">.</span><span class="n">draw_graph_matrix</span><span class="p">(</span><span class="n">D</span><span class="p">,</span><span class="n">kwds</span><span class="o">=</span><span class="n">kwds</span><span class="p">)</span>
        </div>
    <span class="k">def</span> <span class="nf">_dep_draw_matrix_image</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">outputname</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draws an (adjacency) matrix representing this NoddyTopology object. Depreciated version (just</span>
<span class="sd">        loads the .g25 fil that topology opens).</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**</span>
<span class="sd">         - *outputname* = the path of the image to be written. If left as &#39;&#39; the image is written to the same directory as the basename.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c">#try importing matplotlib</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;Could not draw image as matplotlib is not installed. Please install matplotlib&quot;</span><span class="p">)</span>
            
        <span class="c">#get output path</span>
        <span class="k">if</span> <span class="n">outputname</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
            <span class="n">outputname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;_matrix.jpg&quot;</span>
            
        <span class="c">#open the matrix file</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&#39;.g25&#39;</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">):</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    
        <span class="c">#draw &amp; save</span>
        <span class="k">print</span> <span class="s">&quot;Saving matrix image to... &quot;</span> <span class="o">+</span> <span class="n">outputname</span>
        <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s">&#39;Paired&#39;</span><span class="p">)</span>
        <span class="n">cmap</span><span class="o">.</span><span class="n">set_under</span><span class="p">(</span><span class="s">&#39;white&#39;</span><span class="p">)</span>  <span class="c"># Color for values less than vmin</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">&quot;nearest&quot;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">outputname</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        
        
<div class="viewcode-block" id="NoddyTopology.draw_network_image"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.draw_network_image">[docs]</a>    <span class="k">def</span> <span class="nf">draw_network_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputname</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draws a network diagram of this NoddyTopology to the specified image</span>
<span class="sd">        </span>
<span class="sd">        **Arguments**</span>
<span class="sd">         - *outputname* = the path of the image being written. If left as &#39;&#39; the image is written to the same directory as the basename.</span>
<span class="sd">        **Optional Keywords**</span>
<span class="sd">         - *dimension* = &#39;2D&#39; for a 2D network diagram or &#39;3D&#39; for a 3D network diagram. Default is &#39;2D&#39;.</span>
<span class="sd">         - *axis* = the axis to view on for 3D network diagrams</span>
<span class="sd">         - *perspective* = True to use perspective projection, or False for orthographic projection. Default is False.</span>
<span class="sd">         - *node_size* = The size that nodes are drawn. Default is 1500.</span>
<span class="sd">         - *layout* = The layout algorithm used in 2D. Options are &#39;spring_layout&#39; (default), &#39;shell_layout&#39;, &#39;circular_layout&#39; </span>
<span class="sd">                      and &#39;spectral_layout&#39;.</span>
<span class="sd">         - *verbose* = True if this function is allowed to write to the print buffer, otherwise false. Default is False.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c">#import networkx</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
        
        <span class="c">#try importing matplotlib</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;Could not draw image as matplotlib is not installed. Please install matplotlib&quot;</span><span class="p">)</span>
            
            
        <span class="c">#get args</span>
        <span class="n">dims</span><span class="o">=</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;dimension&quot;</span><span class="p">,</span><span class="s">&#39;2D&#39;</span><span class="p">)</span>    
        <span class="n">view_axis</span><span class="o">=</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;axis&quot;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">)</span> <span class="c">#default view along y axis</span>
        <span class="n">perspective</span><span class="o">=</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;perspective&quot;</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">node_size</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;node_size&quot;</span><span class="p">,</span><span class="mi">1500</span><span class="p">)</span>
        <span class="n">layout</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;layout&quot;</span><span class="p">,</span><span class="s">&#39;spring_layout&#39;</span><span class="p">)</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;verbose&quot;</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
        
        <span class="c">#get output path</span>
        <span class="k">if</span> <span class="n">outputname</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
            <span class="n">outputname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;_graph.jpg&quot;</span>
        
        <span class="c">#setup node colours (by lithologies)</span>
        <span class="c">#nCols = map(int,[G.node[n][&#39;lithology&#39;] for n in G.nodes()])</span>
        <span class="n">nCols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">nCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;colour&#39;</span><span class="p">])</span>
            
        <span class="c">#setup colors (by type)</span>
        <span class="n">eCols</span> <span class="o">=</span> <span class="p">[]</span><span class="c">#map(int,[G.edge[e[0]][e[1]][&#39;edgeType&#39;] for e in G.edges()])</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="n">eCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;colour&#39;</span><span class="p">])</span>
        
        
        <span class="c">#calculate node positions &amp; sizes</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_size</span><span class="p">]</span> <span class="o">*</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">if</span> <span class="s">&#39;3D&#39;</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span> <span class="c">#3D layout</span>
            <span class="n">size_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="c">#initialise size array</span>
                <span class="n">size_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_size</span>
                <span class="n">dz</span><span class="o">=</span><span class="mi">1</span> <span class="c">#z buffer</span>
                
                <span class="c">#calculate 2D location (orthographic)</span>
                <span class="k">if</span> <span class="n">view_axis</span> <span class="o">==</span> <span class="s">&#39;x&#39;</span> <span class="ow">or</span> <span class="n">view_axis</span> <span class="o">==</span> <span class="s">&#39;side&#39;</span><span class="p">:</span> <span class="c">#side view</span>
                    <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="n">dz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">view_axis</span> <span class="o">==</span> <span class="s">&#39;y&#39;</span> <span class="ow">or</span> <span class="n">view_axis</span> <span class="o">==</span> <span class="s">&#39;front&#39;</span><span class="p">:</span> <span class="c">#front view</span>
                    <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="n">dz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">view_axis</span> <span class="o">==</span> <span class="s">&#39;z&#39;</span> <span class="ow">or</span> <span class="n">view_axis</span> <span class="o">==</span> <span class="s">&#39;top&#39;</span><span class="p">:</span> <span class="c">#top view</span>
                    <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">dz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                
                <span class="c">#apply perspective correction if necessary</span>
                <span class="k">if</span> <span class="n">perspective</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">dz</span><span class="p">)</span>
                    <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">dz</span><span class="p">)</span>
                    <span class="n">size_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">/</span> <span class="n">dz</span><span class="p">)</span> <span class="o">*</span> <span class="mi">500</span>
                
            <span class="c">#store size array</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">size_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            
        <span class="k">else</span><span class="p">:</span> <span class="c">#2D layout</span>
            <span class="k">if</span> <span class="s">&#39;shell&#39;</span> <span class="ow">in</span> <span class="n">layout</span><span class="p">:</span> <span class="c">#layouts: spring_layout, shell_layout, circular_layout, spectral_layout</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shell_layout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&#39;circular&#39;</span> <span class="ow">in</span> <span class="n">layout</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&#39;spectral&#39;</span> <span class="ow">in</span> <span class="n">layout</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
            
        <span class="c">#print &quot;Position = &quot; + str(pos)</span>
        
        <span class="c">#draw &amp; save</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Saving network image to...&quot;</span> <span class="o">+</span> <span class="n">outputname</span>
        
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">node_color</span><span class="o">=</span><span class="n">nCols</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">eCols</span><span class="p">)</span> <span class="c">#cmap=cm</span>
        
        <span class="c">#nx.draw_networkx_labels(G,pos,font_size=8)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">outputname</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="NoddyTopology.draw_network_hive"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.draw_network_hive">[docs]</a>    <span class="k">def</span> <span class="nf">draw_network_hive</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draws a network hive plot (see https://github.com/ericmjl/hiveplot).</span>
<span class="sd">        The axes of the hive are: node lithology, edge age &amp; edge area.</span>
<span class="sd">        </span>
<span class="sd">        ie. the top axis lists the nodes in stratigraphic order. The second axis</span>
<span class="sd">        lists edges in structural age &amp; thrid axis lists edges by surface area.</span>
<span class="sd">        </span>
<span class="sd">        Nodes are joined to edge-nodes by lines on the graph if they are topologically linked</span>
<span class="sd">        (ie. if an edge has that node as an end point).</span>
<span class="sd">        </span>
<span class="sd">         **Optional Keywords**</span>
<span class="sd">         - *path* = the path to save this figure</span>
<span class="sd">         - *dpi* = the resolution of the figure</span>
<span class="sd">         - *bg* = the background color. Default is black.</span>
<span class="sd">         - *axes* = The color of the axes and labels.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c">#make axes</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[[],[],[]]</span>
        <span class="c">#nb. was lithology</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;age&#39;</span><span class="p">]))</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span> <span class="c">#nodes</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;age&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span> <span class="c">#edges treated as nodes on these axes</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;area&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>
        
        <span class="c">#calculate node positions</span>
        <span class="n">node_positions</span> <span class="o">=</span> <span class="p">[{},{},{}]</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> <span class="c">#axes</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span> <span class="c">#nodes</span>
                <span class="n">node_id</span> <span class="o">=</span> <span class="n">n</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">node_id</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#change form tuple to value</span>
                
                <span class="n">node_positions</span><span class="p">[</span><span class="n">ax</span><span class="p">][</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c">#use node parameter</span>
          
        <span class="c">#drop attributes from node ids</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c">#string contains edge type</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
          
        <span class="c">#calculate edges</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edge_vals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">edges</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]):</span>
                <span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#init list</span>
                <span class="n">edge_vals</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span><span class="c">#&#39;cm&#39; : &#39;alpha&#39;, &#39;color&#39; : d[&#39;colour&#39;]}</span>
                
            <span class="n">e1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="c">#inter group edge</span>
            <span class="n">e2</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">,(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span> <span class="c">#between group edges</span>
            <span class="n">e3</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">,(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
            <span class="n">e4</span> <span class="o">=</span> <span class="p">((</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">),(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
            
            <span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e3</span><span class="p">)</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e4</span><span class="p">)</span>
            
            <span class="n">edge_vals</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]][</span><span class="n">e1</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;colour&#39;</span><span class="p">]</span> <span class="c">#set edge color</span>
            <span class="n">edge_vals</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]][</span><span class="n">e2</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;colour&#39;</span><span class="p">]</span> <span class="c">#set edge color</span>
            <span class="n">edge_vals</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]][</span><span class="n">e3</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;colour&#39;</span><span class="p">]</span> <span class="c">#set edge color</span>
            <span class="n">edge_vals</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;edgeType&#39;</span><span class="p">]][</span><span class="n">e4</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;colour&#39;</span><span class="p">]</span> <span class="c">#set edge color</span>
        
        <span class="c">#make plot</span>
        
        <span class="n">axis_cols</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;axes&#39;</span><span class="p">,[</span><span class="s">&#39;white&#39;</span><span class="p">,</span><span class="s">&#39;white&#39;</span><span class="p">,</span><span class="s">&#39;white&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">axis_cols</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">axis_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis_cols</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            
        <span class="kn">from</span> <span class="nn">pynoddy.experiment.util.hive_plot</span> <span class="kn">import</span> <span class="n">HivePlot</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">HivePlot</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">node_positions</span><span class="o">=</span><span class="n">node_positions</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                     <span class="n">edge_colormap</span><span class="o">=</span><span class="n">edge_vals</span><span class="p">,</span><span class="n">lbl_axes</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Stratigraphic Age&#39;</span><span class="p">,</span>
                                                       <span class="s">&#39;Structural Age&#39;</span><span class="p">,</span>
                                                       <span class="s">&#39;Surface Area&#39;</span><span class="p">],</span>
                                                <span class="n">axis_cols</span><span class="o">=</span><span class="n">axis_cols</span><span class="p">)</span>

        <span class="n">h</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
     </div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="NoddyTopology.draw_mayavi_graph"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.draw_mayavi_graph">[docs]</a>    <span class="k">def</span> <span class="nf">draw_mayavi_graph</span><span class="p">(</span> <span class="n">G</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draws the provided network with mayavi. This requires the Mayavi python library</span>
<span class="sd">        (mayavi.mlab)</span>
<span class="sd">        </span>
<span class="sd">        **Optional Keywords**:</span>
<span class="sd">         - *node_size* = The size of the nodes. Default is 40.</span>
<span class="sd">         - *edge_thickness* = The thickness of the edges. Default is 4</span>
<span class="sd">         - *show* = If true, the model is displayed in the mayavi viewer after exporting. Default is True</span>
<span class="sd">         - *path* = A path to save the mayavi vtk file to after generating it.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mayavi</span> <span class="kn">import</span> <span class="n">mlab</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Error loading mayavi package: mayavi is not installed or is not on the python path. To install with pip, use &#39;pip install mayavi&#39; (or &#39;conda install mayavi&#39;&quot;</span><span class="p">)</span>
            <span class="k">return</span>
            
        <span class="n">node_size</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;node_size&#39;</span><span class="p">,</span><span class="mi">250</span><span class="p">)</span>
        <span class="n">edge_thickness</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;edge_thickness&#39;</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
        
        <span class="c">#convert node labels to integers</span>
        <span class="n">G2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">convert_node_labels_to_integers</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
        <span class="c">#load positions</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nCols</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#node colours</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G2</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">assert</span> <span class="n">G2</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;centroid&#39;</span><span class="p">),</span> <span class="s">&quot;Error: node centroids are not defined.&quot;</span>
            
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">nCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;lithology&#39;</span><span class="p">]))</span>
        
        <span class="c">#get edges of different types</span>
        <span class="n">edge_groups</span> <span class="o">=</span> <span class="p">{}</span> <span class="c">#keys: &#39;type&#39; : (edge,edge_colour,weight_list)</span>
        
        <span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ColorConverter</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">ColorConverter</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G2</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">e_type</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;edgeType&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">edge_groups</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">e_type</span><span class="p">):</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;colour&#39;</span><span class="p">,(</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.3</span><span class="p">))</span>
                <span class="c">#convert matplotlib colours to rgb                </span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span> <span class="n">col</span> <span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                    <span class="n">col</span><span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span> <span class="n">col</span> <span class="p">)</span>
                    
                <span class="c">#edges are stored as follows: ((x_coords,y_coords,zcoords),edge_pairs,colour,values)</span>
                <span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">(([],[],[]),[],</span><span class="n">col</span><span class="p">,[])</span> <span class="c">#Initialise edge type</span>
                
                
            <span class="c">#append start coordinates</span>
            <span class="n">id_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;weight&#39;</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">edge_thickness</span><span class="p">)</span>
            
            <span class="c">#append end coordinates</span>
            <span class="n">id_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;weight&#39;</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">edge_thickness</span><span class="p">)</span>
            
            <span class="c">#append edge pair</span>
            <span class="n">edge_groups</span><span class="p">[</span><span class="n">e_type</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">id_start</span><span class="p">,</span><span class="n">id_end</span><span class="p">)</span> <span class="p">)</span>
                
                       
        <span class="c">#make figure</span>
        <span class="n">mlab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">bgcolor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">mlab</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        
        <span class="c">#make nodes</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">points3d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">nCols</span><span class="p">,</span><span class="n">scale_factor</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span><span class="n">scale_mode</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">,</span><span class="n">resolution</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
        
        <span class="c">#make edges</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">edge_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">edge_groups</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                
            <span class="c">#make start &amp; end points</span>
            <span class="n">pts2</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">points3d</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">scale_factor</span><span class="o">=</span><span class="n">edge_thickness</span><span class="p">,</span><span class="n">scale_mode</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">,</span><span class="n">resolution</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            
            <span class="c">##pts2.mlab_source.set(edge_groups[k][3])</span>
            
            <span class="c">#bind lines</span>
            <span class="n">pts2</span><span class="o">.</span><span class="n">mlab_source</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="c">#build geometry</span>
            <span class="n">tube</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">tube</span><span class="p">(</span><span class="n">pts2</span><span class="p">,</span><span class="n">tube_radius</span><span class="o">=</span><span class="n">edge_thickness</span><span class="p">)</span> 
            <span class="n">tube</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">vary_radius</span> <span class="o">=</span> <span class="s">&#39;vary_radius_by_scalar&#39;</span>
            <span class="n">tube</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">radius_factor</span> <span class="o">=</span> <span class="mi">5</span>
            
            <span class="c">#tube.mlab_source.set(edge_groups[k][3] * edge_thickness)</span>
            
            <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">tube</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="c">#color=(0.3,0.3,0.3))</span>
            
        <span class="c">#ends = mlab.points3d(e_x,e_y,e_z,np_c,scale_factor=edge_thickness,scale_mode=&#39;none&#39;,resolution=10)</span>
        <span class="c">#ends.mlab_source.dataset.lines = np.array(lines)</span>
        <span class="c">#tube = mlab.pipeline.tube(ends,tube_radius=edge_thickness)</span>
        <span class="c">#mlab.pipeline.surface(tube)</span>
        
        <span class="c">#pts.mlab_source.dataset.lines = np.array(G2.edges())</span>
        <span class="c">#tube = mlab.pipeline.tube(pts,tube_radius=edge_thickness)</span>
        <span class="c">#mlab.pipeline.surface(tube,color=np.array(eCols))#color=(0.3,0.3,0.3))</span>
        
        <span class="c">#write</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;path&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">write_data</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;Warning: tvtk not installed - cannot write vtk file.&quot;</span><span class="p">)</span>
            <span class="n">write_data</span><span class="p">(</span><span class="n">pts</span><span class="o">.</span><span class="n">mlab_source</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span><span class="n">kwds</span><span class="p">[</span><span class="s">&#39;path&#39;</span><span class="p">])</span>
            
        <span class="c">#show, if asked</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;show&#39;</span><span class="p">,</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            
            </div>
<div class="viewcode-block" id="NoddyTopology.draw_mayavi"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.draw_mayavi">[docs]</a>    <span class="k">def</span> <span class="nf">draw_mayavi</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draws this network with mayavi. This requires the Mayavi python library</span>
<span class="sd">        (mayavi.mlab)</span>
<span class="sd">        </span>
<span class="sd">        **Optional Keywords**:</span>
<span class="sd">         - *node_size* = The size of the nodes. Default is 40.</span>
<span class="sd">         - *edge_thickness* = The thickness of the edges. Default is 4</span>
<span class="sd">         - *show* = If true, the model is displayed in the mayavi viewer after exporting. Default is True</span>
<span class="sd">         - *path* = A path to save the mayavi vtk file to after generating it.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">NoddyTopology</span><span class="o">.</span><span class="n">draw_mayavi_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            </div>
<div class="viewcode-block" id="NoddyTopology.draw_3d_network"><a class="viewcode-back" href="../../pynoddy.html#pynoddy.output.NoddyTopology.draw_3d_network">[docs]</a>    <span class="k">def</span> <span class="nf">draw_3d_network</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draws a 3D network using matplotlib.</span>
<span class="sd">        </span>
<span class="sd">        **Optional Keywords**:</span>
<span class="sd">         - *show* = If True, the 3D network is displayed immediatly on-screen in an</span>
<span class="sd">                    interactive matplotlib viewer. Default is True.</span>
<span class="sd">         - *output* = If defined an image of the network is saved to this location.</span>
<span class="sd">         - *node_size* = The size of the nodes. Default is 40.</span>
<span class="sd">         - *geology* = a NoddyOutput object to draw with the network</span>
<span class="sd">         - *res* = resolution to draw geology at. Default is 4 (ie 1/4 of all voxels are drawn)</span>
<span class="sd">         - *horizons* = a list of geology surfaces to draw. Default is nothing (none drawn). Slow!</span>
<span class="sd">                        See NoddyOutput.get_surface_grid for details.</span>
<span class="sd">         - *sections* = draw geology sections. Default is True.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        
        <span class="n">node_size</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;node_size&#39;</span><span class="p">,</span><span class="mi">40</span><span class="p">)</span>
        
        <span class="n">G2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">convert_node_labels_to_integers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        
        <span class="c">#make figure</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s">&#39;3d&#39;</span><span class="p">)</span>
        
        <span class="c">#load geology</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;geology&#39;</span><span class="p">):</span>
            <span class="n">base</span><span class="o">=</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;geology&#39;</span><span class="p">)</span>
            <span class="n">res</span><span class="o">=</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;res&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;sections&#39;</span><span class="p">,</span><span class="bp">True</span><span class="p">):</span> <span class="c">#plot sections</span>
                
                <span class="c">#get sections</span>
                <span class="n">sections</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">get_section_lines</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">base</span><span class="o">.</span><span class="n">get_section_lines</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>                        
                
                <span class="c">#plot sections</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">k</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">k</span><span class="p">],</span><span class="n">zdir</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                        
            <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;horizons&#39;</span><span class="p">):</span> <span class="c">#plot surfaces</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;horizons&#39;</span><span class="p">)</span>
                <span class="n">surfaces</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">get_surface_grid</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="c">#range(0,base.n_rocktypes) #[12,14]</span>
                
                <span class="c">#draw surfaces</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">surfaces</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">])):</span> <span class="c">#draw line segments</span>
                        <span class="c">#ax.scatter(sx[k],sy[k],sz[k],s=2,linewidths=(0,),zdir=&#39;z&#39;,antialiased=False)</span>
                        <span class="c">#ax.plot_trisurf(sx[k],sy[k],sz[k],color=&#39;r&#39;,alpha=0.6,antialiased=False)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">k</span><span class="p">],</span><span class="n">zdir</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
                    
        <span class="c">#load positions</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nCols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G2</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">G2</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;centroid&#39;</span><span class="p">):</span>
                <span class="k">print</span> <span class="s">&quot;Error: node centroids are not defined. Please ensure this topology object has not been collapsed&quot;</span>
                <span class="k">return</span>
            
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;centroid&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">nCols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;lithology&#39;</span><span class="p">]))</span>
        
        <span class="c">#make nodes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">zdir</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">nCols</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node_size</span> <span class="p">)</span>
        
        <span class="c">#make edges</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G2</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">G2</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;centroid&#39;</span><span class="p">]</span>
            
            <span class="c">#todo: get edge colour</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;colour&#39;</span><span class="p">]</span>
            <span class="c">#build lists</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                       
            <span class="c">#draw line</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">zdir</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
           
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;output&#39;</span><span class="p">):</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;output&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;show&#39;</span><span class="p">,</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
            
 </div></div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c"># some testing and debugging functions...</span>
<span class="c">#     os.chdir(r&#39;/Users/Florian/git/pynoddy/sandbox&#39;)</span>
<span class="c">#     NO = NoddyOutput(&quot;strike_slip_out&quot;)</span>
    <span class="c">#os.chdir(r&#39;C:\Users\Sam\Documents\Temporary Model Files&#39;)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s">r&#39;C:\Users\Sam\OneDrive\Documents\Masters\Models\Primitive\Fold+Unconformity+Intrusion+Fault&#39;</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pk</span>
    
    <span class="n">st</span> <span class="o">=</span> <span class="n">pk</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;super_topology.pkl&#39;</span><span class="p">))</span>
    
    <span class="n">NoddyTopology</span><span class="o">.</span><span class="n">draw_mayavi_graph</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
    
    
    <span class="c">#NO = &quot;NFault/NFault&quot;</span>
    <span class="c">#NO = &#39;Fold/Fold_Fault/fold_fault&#39;</span>
    <span class="c">#NO = &#39;GBasin&#39;</span>
    
    <span class="c">#create NoddyTopology</span>
    <span class="c">#geo = NoddyOutput(NO)</span>
    <span class="c">#topo = NoddyTopology(NO,load_attributes=True)</span>
    
    <span class="c">#topo.export_vtk(show=True)</span>
    <span class="c">#topo.draw_mayavi()</span>
    <span class="c">#topo_c = topo.collapse_topology()</span>
    <span class="c">#print len( topo_c.graph.edges() )</span>
    <span class="c">#print len( topo.graph.edges() )</span>
    
    <span class="c">#draw network</span>
    <span class="c">#topo.draw_network_image(dimension=&#39;3D&#39;,perspective=False,axis=&#39;x&#39;)</span>
    
    <span class="c">#topo.draw_3d_network(geology=geo,show=True,horizons=[4])</span>
   <span class="c"># topo.draw_adjacency_matrix()</span>
   <span class="c"># topo.draw_network_hive()</span>
    
    <span class="c">#struct = topo.collapse_stratigraphy()</span>
    <span class="c">#struct.draw_matrix_image()</span>
    
    <span class="c">#litho = topo.collapse_topology()</span>
    <span class="c">#litho.draw_matrix_image()</span>
    
    <span class="c">#draw matrix</span>
    <span class="c">#topo.draw_matrix_image()</span>
    
    <span class="c">#draw 3D network</span>
    <span class="c">#topo.draw_3d_network()</span>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pynoddy  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../pynoddy.html" >pynoddy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Florian Wellmann, Sam Thiele.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>